---
categories:
  - UPMP
---
# 2021.11.30上线Bug分析

## 1. Interge 和 Long类型转换问题

问题描述：

```java
 Map<Long, List<SpecialwareTypeStatPO>> specialwareTypeStat = new HashMap<>();
         specialwareTypeStat.put(12345L, Lists.newArrayList(SpecialwareTypeStatPO.builder().activityId(12345l).reachBrandNewUserCount(12).build()));
         System.out.println(specialwareTypeStat.get(12345));
```

Map<Long, Object> map；使用get的时候按Integer获取，获取结果为null。

```java
 public V get(Object key) {
        Node<K,V> e;
        return (e = getNode(hash(key), key)) == null ? null : e.value;
    }

    /**
     * Implements Map.get and related methods
     *
     * @param hash hash for key
     * @param key the key
     * @return the node, or null if none
     */
    final Node<K,V> getNode(int hash, Object key) {
        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;
        if ((tab = table) != null && (n = tab.length) > 0 &&
            (first = tab[(n - 1) & hash]) != null) {
            if (first.hash == hash && // always check first node
                ((k = first.key) == key || (key != null && key.equals(k))))
                return first;
            if ((e = first.next) != null) {
                if (first instanceof TreeNode)
                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);
                do {
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        return e;
                } while ((e = e.next) != null);
            }
        }
        return null;
    }
```

其中进行判断node时，会进行判断 if (first.hash == hash && // always check first node
                ((k = first.key) == key || (key != null && key.equals(k))))

关键是下一句两个判断都是false。

> 1. ```
>    Object xc = new Long(12345);
>    System.out.println(aa1 == xc);
>    //始终是false aa1是Integer xc是Object
>    ```
>
> 2. ```java
>    equals 也是区分 instanseof的
>    ```

补充：

```java
  Integer aa = new Integer(10);
  Long bb1 = new Long(12345);
  System.out.println((12345 == bb1) + ":" + (12345 == aa1) + ":" + (10 == aa) );
  System.out.println((bb1.equals(12345L)) + ":" + (aa1.equals(12345)) + ":" + (aa.equals(10)) );
  Integer i = 12345;
  int ii = 12345;
  Integer iii = 12345;
  System.out.println( (i==iii) +":"+(i.equals(iii)) );
  System.out.println((i == aa1) +":"+ (i.equals(aa1)) + ":" + (i == ii) + ":" + (ii == aa1));
```

true:true:true
true:true:true
false:true
false:true:true:true

Integer 和 Integer 用 == 比较 有区间缓存 [127,-128]

int比较任何包装类型都是 按 基本类型比较

equals区分对象类型（Instanceof）

## 2.运营看板，活动列表查询后覆盖问题

首先 当前周期和上一周期对比，用当前周期colne的类，覆盖了周期属性。考虑到查询条件中的活动列表会重新Set就没有在spuer里重写。但查询上一周期的活动列表的mybatis语句中为兼容活动看板，对活动参数放在了查询条件中，因此活动列表查询有出入。导致Set的属性有误。

总结： 1. 新功能在原有功能上添加时有尽量考虑对原功能的影响。

2.修改bug时要考虑改动范围，避免改动过大影响其他功能。本意想在super.Clone里把活动属性清空，但是还有部分clone是克隆计算任务时不能够覆盖活动列表的。