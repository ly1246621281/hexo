---
categories:
  - UPMP
---
# 行锁问题

## 问题描述：

单行更新，在启动10个压测脚本，并行量为275时，出现行锁发生。

## 问题解决思路：

1. mysql处设置行锁释放时间

   mysql查询到可以设置行锁等待超时时间，超时时间到之后发出timeoutException.网上多是增加超时时间，避免出错。亦或是找到行锁线程，kill掉解决.

   ` show variables like 'innodb_lock_wait_timeout';` dbquery默认30s.

   [1.mysql超时分析](https://www.cnblogs.com/christopherchan/p/12390819.html)

   [2.mysql超时分析](http://www.51testing.com/html/16/390216-838016.html)

   [3.Transactional超时时间控制与mysql事务超时时间：](https://blog.csdn.net/educast/article/details/78824028)

2. spring事务与mysql事务处设置

   当前为当行语句行锁发生，不涉及，参考如上3

3. mysql单行超时设置

   单行超时释放连接。

   ```mysql
   <select id="getXXXX" parameterType="java.lang.String" resultMap="dataMap" timeout="1">
    
   </select>
   ```

   参考[Mybatis设置sql超时时间](https://blog.csdn.net/shuimuz_j/article/details/9674427)

   [很全的分析=-==mybatis设置MySQL超时时间_怎样配置MySQL数据库超时设置？](https://blog.csdn.net/weixin_28707365/article/details/113241314?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-5.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-5.no_search_link)
   
   很全的分析 https://zhuanlan.zhihu.com/p/43746959
   
## 超时返回后是否Mysql仍在执行问题

   为了验证上面问题，使用了Mysql的查询进程命令

   ` show full processlist ;`

   配合SQL  ` select sleep(50) `  和 ` kill  query  xx`  ` kill xx`

   

   发现

   1. Mybatis查询超时时间设置 ：如上 timeout 或者 defaultStatementTimeout设置，是JDBC的查询超时设置  。
   
   2. tcpSocketTimeout超时时间 是JDBC连接在ConnectionPropertiesImpl属性文件里的设置，参考 queryTimeoutKillsConnection  （查询超时断开连接）socketTimeout（超时断开tcp连接）。这两种配置均可在前台展示timeoutException，但是后台Mysql Server仍在执行sql。
   
   3. 连接池的queryTimeout超时时间 ，设置后发现无效。 
   
      ```
      queryTimeout: 5
      killWhenSocketReadTimeout: true
      ```

url的connect连接上配置timeout和在dataSource（连接池上）配置效果一样

>jdbc 有2个超时时间, 一个是queryTimeout, 一个是socketTimeout,queryTimeout的作用是sql执行超时之后,可以取消这次的执行,底层原理是发送kill $id通知mysql来中断这个sql的执行
> 
>socketTimeout的作用主要是为了解决tcp连接超时的问题, 超时之后,这个tcp连接会断开要注意的是,socket超时只是释放tcp链接, 但sql还是在mysql里面执行(可以通过show processlist来看到)所以为了取消sql的执行,socketTimeout的时间一定要大于queryTimeout才有意义

4. ```java
   @Transactional(value = "transactionManager", timeout=1)
   事务超时 同样简单
   ```

参考了 [深入分析JDBC超时机制](https://zhuanlan.zhihu.com/p/28308813)



![img](https://pic2.zhimg.com/80/v2-308faf4a7cc1fa62c47df1e9966f8599_1440w.png)

现在我们要查test库中使用情况，我们可以到information_schema中查询 
       解释：information_schema这张数据表保存了MySQL服务器所有数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等。再简单点，这台MySQL服务器上，到底有哪些数据库、各个数据库有哪些表，每张表的字段类型是什么，各个数据库要什么权限才能访问，等等信息都保存在information_schema表里面。

我们可以用下面三张表来查原因： 
       innodb_trx ## 当前运行的所有事务 
       innodb_locks ## 当前出现的锁 
       innodb_lock_waits ## 锁等待的对应关系

此时我们在navcat中操作如下的指令，就会看到所有先执行事务的语句操作，

然后我们找到状态 trx_state 被锁的状态，然后使用kill命令干掉它就可以

 

-- 查看 所有mysql 进程id
show full PROCESSLIST;

-- 查看mysql 事务处理列表
select * from information_schema.INNODB_TRX  
————————————————
版权声明：本文为CSDN博主「不会推车的娘们」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/shmily_lsl/article/details/82696097

[Spring各种超时](https://zhuanlan.zhihu.com/p/43746959)