---
categories:
  - UPMP
---
# 生产问题记录：毫秒粒度诉求造成问题

## 背景：

分布式4台容灾机器，由一台机器去拉取远端缓存并广播消息通知各C端前置容器。4台机器每台容器有10ms的定时任务去拉取远端缓存。

## 问题：

4台容灾机器抢分布式锁保证只有一台容器执行，选定的容器10ms执行一次任务，1分钟执行6K次；但生产的ump监控仅1分钟百十次。

## 问题代码：

![image-20230704155321927](https://raw.githubusercontent.com/ly1246621281/PicGo/main/img/image-20230704155321927.png)

> 设计思路：
>
> 1.使用getStockCountTimestampVersion 时间戳版本去实现分布式NX锁。增加10ms误差去容错4台机器时钟误差。
>
> 2.1台机器抢锁成功后，放置当前远端分布式时间钟作为库存变更版本，后续根据提前获取的版本号（上一版本）做缓存信息获取并广播。

### 上述需求可能发生问题：

1.各分布式容器可能有时钟误差，因此使用远端的时钟

2.当前容器抢锁成功后，设置下次时间戳版本（尽早）。但是增加容错10ms后，若放置的时候因==jimdb操作延时导致延==后，下次10msWorker正常执行，并再次放置当前正常的时间戳，下次执行会导致防重锁生效（1分钟）。无法再次更新版本号

![image-20230704163501449](https://raw.githubusercontent.com/ly1246621281/PicGo/main/img/image-20230704163501449.png)

## 修正：

```java
/**
 * 该前置任务分组中某台机器抢锁后，计算好数据后广播各前置匹配分组
 */
public void pullChangeActivityStockCountFromRemoteAndBroadcast(){
    //如果分组不是前置定时任务分组，则返回
    if(!onlineGroupUtils.isPreJobGroup()){
        return;
    }
    final ScheduledFuture<?> pullHandle = scheduler.scheduleAtFixedRate(() -> {
        String stockCountTimestampVersion = null;
        CallerInfo callerInfo = Profiler.registerInfo("Upmp2.StockCount10msJob.pullChangeActivityStockCountFromRemoteAndBroadcast");
        try {
            //使用remote分布式value做key，避免机器时钟以及redis延时问题造成的操作阻塞
            String currentTime = remoteCacheService.getCurrentTimestamp();
            String nxLockKey = "stockBroadNx_" + currentTime.substring(0, currentTime.length() - 1);
            boolean nxLock = remoteCacheService.judgeRetryGate(nxLockKey);
            if (nxLock) {
                log.info("[库存本地汇总]10ms拉取Jimdb数据并广播任务，抢锁成功.时间戳版本为：{}", nxLockKey);
                stockCountTimestampVersion = remoteCacheService.getStockCountTimestampVersion();
                //更新下次时间版本戳
                remoteCacheService.updateStockCountTimestampVersion(currentTime);
                //异步广播库存量变更信息,广播增加版本号概念
                stockCountBroadcastProducer.asyncSendLocalStockChangeMq(stockCountTimestampVersion);
            }else {
                log.debug("[库存本地汇总]该机器抢锁失败,无需broadcast库存信息");
            }
        } catch (Throwable e) {
            log.error("[库存本地汇总]Jimdb操作异常.stockCountTimestampVersion:{}",stockCountTimestampVersion, e);
            //报警
            Profiler.businessAlarm("Upmp2.stockCount10msJob.recordActivityStockCount.warn", "[warn]库存本地汇总Worker执行异常,pullFromRemoteAndBroadcast");
            Profiler.functionError(callerInfo);
        }finally {
            Profiler.registerInfoEnd(callerInfo);
        }
    }, System.currentTimeMillis()%10, fixedMillisecond, MILLISECONDS);
}
```

**使用remote分布式value做key，避免机器时钟以及redis延时问题造成的操作阻塞**

