---
categories:
  - JAVA总结
  - JAVA（2020--2023）
---
# 自定义注解

## 1.demo:

```java
package com.jd.y.upack.core.service.core.config;

import com.jd.y.upack.core.config.dynamic.match.ServiceSwitchConfig;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;

/**
 * 功能描述：
 *
 * @Author: zhangkai324
 * @Date: 2021/9/6 16:38
 */
@Aspect
@Component
@Slf4j
public class ServiceCheckAspect {
    @Resource
    com.jd.y.upack.core.config.dynamic.match.ServiceSwitchConfig serviceSwitchConfig;

    @Pointcut("@annotation(com.jd.y.upack.core.service.core.config.ServiceCheck)")
    public void login() {
    }


    @Before("@annotation(sv)")
    public void demoBefore(JoinPoint joinPoint, ServiceCheck sv) {
        log.info("@before 开始");
        log.info("注解参数:"+sv.switchName()+":"+sv.retryGateKey());
        log.info("目标方法的参数对象:{}",  joinPoint.getArgs().toString());
        log.info("被代理的对象:{}",  joinPoint.getTarget());
        log.info("代理对象:{}",  joinPoint.getThis());
        log.info("目标方法名为:{}",  joinPoint.getSignature().getName());
        log.info("目标方法所属类的简单类名:{}",  joinPoint.getSignature().getDeclaringType().getSimpleName());
        log.info("目标方法所属类的类名:{}",  joinPoint.getSignature().getDeclaringTypeName());
        log.info("目标方法声明类型:{}",  Modifier.toString(joinPoint.getSignature().getModifiers()));
    }

    @After("login()")
    public void demoAfter(JoinPoint joinPoint) {
        //....
        log.info("@After 结束.");
    }

    @AfterThrowing("login()")
    public void demoAfterThrowing(JoinPoint joinPoint) {
        //....
    }

    @Around("@annotation(sv)")
    public Object demoAround(ProceedingJoinPoint pjp, ServiceCheck sv) throws Throwable {

        log.info("@Around 开始校验。。。");
        Object[] args = pjp.getArgs();
        log.info("@Around {}，sv.RetryGateKey()：{}。。。", sv.switchName(), sv.retryGateKey());

        Class x = serviceSwitchConfig.getClass();
        Field declaredField = x.getDeclaredField(sv.switchName());
        declaredField.setAccessible(true);
        boolean switchOn = false;

        Object o1;
        if(declaredField  == null){
            log.info("switchName:{} , true", sv.switchName());
        }else{
            // switchOn = declaredField.getBoolean(serviceSwitchConfig);
            o1 = declaredField.get(serviceSwitchConfig);
            if(o1 instanceof Boolean){
                switchOn = (boolean)o1;
            }else {
                log.info("######{} switchOn param is uncorrect.", sv.switchName());
                return null;
            }
        }
        if(!switchOn){
            log.info("######{} switchOn is off.", sv.switchName());
            return null;
        }
        Object proceed = pjp.proceed(args);
        log.info("@Around ：{}。。。", proceed);
        return proceed;
    }

}

```

## 2.注意事项

* @Around 环绕有返回值, 其他没有返回值，只是日志记录或者做些前置后置操作。
  * 执行顺序  @Around， @Before,  ProceedingJoinPoint.processd, @Around, @After

* before中 反射输出：

  ![image-20210909115823534](https://raw.githubusercontent.com/ly1246621281/PicGo/main/img/image-20210909115823534.png)





```java
 @Pointcut("@annotation(com.jd.y.upack.core.service.core.config.ServiceCheck) || execution(public * com.jd.y.upack.core.service.*.*(..))")
    public void dataPointCut() {

    }
    @Before("dataPointCut()")
    public void demoBefore(JoinPoint joinPoint) {
        log.info("@before 开始");
        log.info("目标方法的参数对象:{}",  joinPoint.getArgs().toString());
        log.info("被代理的对象:{}",  joinPoint.getTarget());
        log.info("代理对象:{}",  joinPoint.getThis());
        log.info("目标方法名为:{}",  joinPoint.getSignature().getName());
        log.info("目标方法所属类的简单类名:{}",  joinPoint.getSignature().getDeclaringType().getSimpleName());
        log.info("目标方法所属类的类名:{}",  joinPoint.getSignature().getDeclaringTypeName());
        log.info("目标方法声明类型:{}",  Modifier.toString(joinPoint.getSignature().getModifiers()));
    }

    @Around("dataPointCut() && @annotation(sv)")
    public Object demoAround(ProceedingJoinPoint pjp, ServiceCheck sv) throws Throwable 
```

1. 切点pointCut 上可以有普通逻辑运算符 && || ！
2. 切面支持切接口，但是PointCut需要写包名/类名直接切。
3. 注解方式测试不支持接口切面
4. 注意切点上的**&&**，必须同时满足





[切面语法](https://www.cnblogs.com/muxi0407/p/11882586.html)