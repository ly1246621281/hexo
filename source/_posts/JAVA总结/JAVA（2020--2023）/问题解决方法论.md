---
categories:
  - JAVA总结
  - JAVA（2020--2023）
---
# 问题解决方法论

## 1.首先要跳出解决问题表面范畴，思考影响问题根本原因
eg.B端出库量统计慢，导致C端数据库影响（表面活动的实时库存量需要提前处理，思路定格在活动方面的出库量）后面引申至活动-仓维度库存量。
真实库存量问题是订单增量的问题，B端只是要统计然后才有活动要统计出库量的问题。
## 2.确定清楚影响问题的根本原因之后，思考解决方案，并确定影响范围
订单实时增加，worker去扫描活动中状态活动的出库量自然不如扫描增量订单合适，根本原因是订单状态变化，活动出库量只是表面场景。
影响范围有出库量总数，仓维度总数还有日趋势图的出库量。仓维度和总量可以一并做，但是日趋势图这个只要有一单状态变更，要将该活动所有派发日期都有实时汇总一遍，自然有些投入产出不成比例。但不改的话业务口径不统一，正确性会被质疑。
## 3.影响范围梳理清楚，若遇到投入产出问题时，回归问题本身，进而求出当前应该做什么，该怎么做。
我们要根本要解决的是C端数据库问题，而统计慢也想一并解决但不是问题根本。所以回归回来就是不进行日趋势图统计，用从库解决C端问题，但作为一个追求完美的人来讲，仓维度和总出库量可以解决就解决，所以，此刻对于正确性问题，可以使用一个动态开关，同时解决C端和统计慢问题，若业务质疑统计一致性，可关闭读中间表的方案，让其实时去查从库。
此刻问题解决。
==回归方法论：解决问题从根本影响因素出发，解决问题要跟随问题本身，解决问题无法完美时要有兜底方案。==

问题引申：

> 要对订单表的历史数据进行刷数，考虑程序自动化刷数，但表里有6.7千万条左右订单数据，虽然会对活动号分页去做，但是难免数据量太大，sql效率不高，考虑对订单号的maxId去分页，弄个双层循环处理，外层订单id内层活动分页。
>
> 问题出来了，得切割活动号，另外最近搞的圈复杂度高了。

回归问题，刷历史数据，使用MaxId，通过ducc手动运维的方式去解决一次性处理问题，简单省事，避免写代码！！！