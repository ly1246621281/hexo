---
categories:
  - JAVA总结
  - JAVA（2020--2023）
---
# 公司中间件学习

## 1.JMQ

1.jmq基础知识

#### 连接通道配置： jmq:transport

- TransportConfig 常用属性说明(此类型对应spring配置文件中的 <jmq:transport .../>标签)

- app不重要  关注address user pass、

#### MessageProducer  jmq:producer

 #### Listener （分为监听器模式和拉取模式）

| `maxConcurrent` | `连接单组broker最大并发数,客户端实际线程数为单组运行的线程数*broker数（一般不需要配置，默认等于对列数）` |
| --------------- | ------------------------------------------------------------ |
| `minConcurrent` | `连接单组broker最小并发数（一般不需要配置）`                 |

> **拉取模式指用户在代码里主动调用pull方法，不需要在配置文件里面再配置**<jmq:listener />，拉取的速度由用户控制，调用一次拉取一次消息进行消费，用户自己启用多线程控制并行度。
>
> method: pull(String topic,MessageListener listener)
>
> topic:指消费的主题名
>
> listener:是一个回调对象，当pull拉取到消息后会主动调用listener.onMessage()，
>
> 与监听模式的区别是:监听模式由JMQ客户端守护线程去不停的拉取消息进行消费，拉取模式由用户控制拉取的频率，不主动调用就不会消费消息。但是都不需要主动对消息进行确认
>
> 默认监听模式

  

[[JMQ客户端使用说明](https://cf.jd.com/pages/viewpage.action?pageId=198882084)]https://cf.jd.com/pages/viewpage.action?pageId=198882084





## 5.SPRING

**BeanDefinition** 

由于BeanDefinition的数据来源是我们定义的xml相关的Bean，所以自然BeanDefinition的注册过程就是对于xml的解析过程以及对相关元素赋值的过程，在Spring框架中解析<Bean>元素过程中不是创建和实例化Bean对象，而是通过创建BeanDefinition对象，并将<Bean>元素的相关配置信息填充到BeanDefinition中作为记录，当依赖注入时才使用这些记录的相关信息通过BeanFactory进行实例化具体的Bean对象（就是先下个定义，需要时在使用），众多的BeanDefinition可通过BeanDefinitionHolder集中管理。
Spring提供了主要两种bean Definition解析器，都继承自AbstractBeanDefinitionReader

[Spring体系总结（一）：BeanDefinition](https://blog.csdn.net/qq_36931982/article/details/82747721?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-82747721-blog-88880196.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-82747721-blog-88880196.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=1)

